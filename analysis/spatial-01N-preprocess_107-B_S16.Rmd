---
author: "James Howe"
params:
  dataset: "107-B_S16"
  input_path: "data/sequencing/Spatial/"
  output_path: "output/spatial/"
title: "Spatial preprocessing: `r params$dataset`"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

# Introduction

This notebook is a basic workflow to go from raw CellRanger ATAC pipeline output to a pre-processed, Signac-formatted dataset with low-quality cells and outliers removed.  Most filtering steps are generally found in other papers, as listed in the methods.

```{r setup, message = FALSE, warning = FALSE}
# set up paths
input <- params$input_path
output <- params$output_path
id <- params$dataset
path <- paste0(input, id)
output_path <- paste0(output, id)

# import helper scripts
source("code/sequencing_misc.R")
source("code/sequencing-color_scales.R")
source("code/sequencing-plot_functions.R")

# load packages
require(tidyverse)
require(Seurat)
require(SeuratData)
require(patchwork)
require(hdf5r)
require(Matrix.utils)
require(knitr)
require(future)
require(scCustomize)
require(clustree)

# set up parallelization, multisession for compatibility purposes, assuming 32GB RAM
plan("multisession", earlySignal = TRUE, gc = TRUE)
options(future.globals.maxSize = 32 * 1024 ^ 3)

# all images are PDFs, avoids pixelation
knitr::opts_chunk$set(dev = 'pdf')
```

# Load the data

Reads in the singlecell.csv file generated by CellRanger ATAC containing metadata from the pipeline useful for QC steps. Generates initial pre-QC (but post-CellRanger cell calling) metrics, a knee plot (for observation of the general per-cell library complexity), and a peak targeting plot (to determine relationship between per-cell library complexity and peak enrichment).

## Read in data {.tabset}

```{r 1-read_data, message = FALSE, warning = FALSE}
array <- Load10X_Spatial(path)
```

# Examine metrics {.tabset}

## Complexity {.tabset}

### Scatter

```{r 2-complexity_plot, warning = FALSE, message = FALSE}
# Store pre-filter population metrics for plotting
plot_complex_array <- cbind.data.frame(array$nCount_Spatial, 
                                       array$nFeature_Spatial, 
                                       array$nFeature_Spatial > 1)
colnames(plot_complex_array) <- c("UMIs", "Genes", "Include all")

filter_plot(plot_complex_array, "Genes", "UMIs", "Include all")
```

### Histogram {.tabset}

#### Genes

```{r 3-complexity_histogram_genes, warning = FALSE, message = FALSE}
filter_histogram(plot_complex_array, "Genes", "Include all", 20, 0)
```

#### UMIs

```{r 4-complexity_histogram_features, warning = FALSE, message = FALSE}
filter_histogram(plot_complex_array, "UMIs", "Include all", 100, 0)
```

### Map {.tabset}

#### UMIs

```{r 5-complexity_map_umis, warning = FALSE, message = FALSE}
SpatialFeaturePlot(array, features = "nCount_Spatial", pt.size.factor = 5) + 
  theme(legend.position = "right")
```

#### Genes

```{r 6-complexity_map_genes, warning = FALSE, message = FALSE}
SpatialFeaturePlot(array, features = "nFeature_Spatial", pt.size.factor = 5) + 
  theme(legend.position = "right")
```

## Mitochondrial reads {.tabset}

### Scatter

```{r 7-mito_plot, warning = FALSE, message = FALSE}
# add non-nuclear read proportion metadata
Mito_proportion <- Matrix::colSums(array[grepl("^mt-|-mt-", rownames(array)),]) / array$nCount_Spatial * 100
array <- AddMetaData(array, Mito_proportion, col.name = "Mito_proportion")

plot_mito_array <- cbind.data.frame(array$nCount_Spatial, 
                                    array$Mito_proportion,
                                    array$Mito_proportion <= 100)
colnames(plot_mito_array) <- c("UMIs", "Mito_proportion", "Include all")

filter_plot(plot_mito_array, "UMIs", "Mito_proportion", "Include all")
```

### Histogram

```{r 8-mito_histogram, warning = FALSE, message = FALSE}
filter_histogram(plot_mito_array, "Mito_proportion", "Include all", .5, 50)
```

### Map

```{r 9-mito_map, warning = FALSE, message = FALSE}
SpatialFeaturePlot(array, features = "Mito_proportion", pt.size.factor = 5) + 
  theme(legend.position = "right")
```

## Ribosomal reads

### Scatter

```{r 10-ribo_plot, warning = FALSE, message = FALSE}
# add non-nuclear read proportion metadata
Ribo_proportion <- Matrix::colSums(array[grepl("rpl|rps", rownames(array)),]) / array$nCount_Spatial * 100
array <- AddMetaData(array, Ribo_proportion, col.name = "Ribo_proportion")

plot_ribo_array <- cbind.data.frame(array$nCount_Spatial, 
                                    array$Ribo_proportion,
                                    array$Ribo_proportion <= 100)
colnames(plot_ribo_array) <- c("UMIs", "Ribo_proportion", "Include all")

filter_plot(plot_ribo_array, "UMIs", "Ribo_proportion", "Include all")
```

### Histogram

```{r 11-mito_histogram, warning = FALSE, message = FALSE}
filter_histogram(plot_ribo_array, "Ribo_proportion", "Include all", .01, 3)
```

### Map

```{r 12-complexity_map_umis, warning = FALSE, message = FALSE}
SpatialFeaturePlot(array, features = "Ribo_proportion", pt.size.factor = 5) + 
  theme(legend.position = "right")
```

# Transform data

Data needs to be transformed and then clustered to create a dataset that can be subsetted. 

SCTransform is the best performing normalization method. It uses a variance stabilizing transform based on Pearson residuals to eliminate count depth differences and robustly approximate log-normalization. 5000 genes are selected as highly variable genes to ensure maximum resolution while removing non-informative features.

```{r 13-sctransform, message = FALSE, warning = FALSE}
# needs conserve.memory = TRUE, or else it crashes R session on laptop
array <- SCTransform(array, variable.features.n = 5000, residual_type = "pearson", 
                     conserve.memory = TRUE, return.only.var.genes = TRUE, verbose = FALSE,
                     assay = "Spatial")
```

# Dimensionality Reduction

## Principal Component Analysis

Runs a principal component analysis on the imported array using Seurat's RunPCA function, returning results for the first 50 principal components. We aim to use all 50 top principal components explaining for downstream clustering. Adding principal components beyond the first 50 has strong diminishing returns and only serves to introduce noise into the reduction in most cases.

```{r 14-pca, message = FALSE, warning = FALSE}
array <- RunPCA(array, verbose = FALSE)

# create array for downstream plotting, with PCs, total variance, and cumulative variance
plot_var_array <- cbind.data.frame(c(1:50),
                                   (array@reductions$pca@stdev)^2
                                   / array@reductions$pca@misc$total.variance,
                                   cumsum((array@reductions$pca@stdev)^2
                                           / array@reductions$pca@misc$total.variance))
colnames(plot_var_array) <- c("PC", "Proportion_variance", "Cumulative_variance")

cat(paste0("First 50 PCs explain ", round(plot_var_array$Cumulative_variance[50]*100, 1), "% of the variance"))
```

### Variance Explained

```{r 15-var_explained, message = FALSE, warning = FALSE}
variance_explained_plot(plot_var_array)
```

## Visualization (non-linear DR): tSNE and UMAP {.tabset}

The top two principal components are generally unsuitable for visualizing single cell -omics data. As a result, non-linear dimensionality reduction incorporating all relevant top PCs must be used. This is implemented via tSNE or UMAP. Seurat's tSNE implementation is sufficient at default settings. via UMAP, using Seurat's native RunUMAP function, running uwot under the hood. The number of epochs has been increased to 1000 from defaults (because it increases stability), and the min.dist has been raised to 0.5 (because it makes global structure more legible).

```{r 16-tsne_umap, message = FALSE, warning = FALSE}
array <- RunTSNE(array, verbose = FALSE, dims.use = 1:50)
array <- RunUMAP(array, verbose = FALSE, dims = 1:50, n.epochs = 1000, min.dist = 0.1)
```

### UMIs {.tabset}

```{r 17-dr_umis, message = FALSE, warning = FALSE, results = "hide"}
src_list <- mapply(function(tab_name, dr_type) {
    src <- c(
        "#### {{tab_name}} {.unnumbered}",
        "```{r umis-{{tab_name}}, message = FALSE, warning = FALSE}",
        "feature_plot_formatted(array, '{{dr_type}}', 'nCount_Spatial', c('lightgrey', 'blue'), NA)",  
        "```",
        ""
    )
    knit_expand(text = src)
}, dr_params$name, dr_params$type)
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

### Genes {.tabset}

```{r 18-dr_genes, message = FALSE, warning = FALSE, results = "hide"}
src_list <- mapply(function(tab_name, dr_type) {
    src <- c(
        "#### {{tab_name}} {.unnumbered}",
        "```{r genes-{{tab_name}}, message = FALSE, warning = FALSE}",
        "feature_plot_formatted(array, '{{dr_type}}', 'nFeature_Spatial', c('lightgrey', 'blue'), NA)",  
        "```",
        ""
    )
    knit_expand(text = src)
}, dr_params$name, dr_params$type)
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

### % Mito {.tabset}

```{r 19-dr_mito, message = FALSE, warning = FALSE, results = "hide"}
src_list <- mapply(function(tab_name, dr_type) {
    src <- c(
        "#### {{tab_name}} {.unnumbered}",
        "```{r mito-{{tab_name}}, message = FALSE, warning = FALSE}",
        "feature_plot_formatted(array, '{{dr_type}}', 'Mito_proportion', c('lightgrey', 'blue'), NA)",  
        "```",
        ""
    )
    knit_expand(text = src)
}, dr_params$name, dr_params$type)
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

### % Ribo {.tabset}

```{r 20-dr_ribo, message = FALSE, warning = FALSE, results = "hide"}
src_list <- mapply(function(tab_name, dr_type) {
    src <- c(
        "#### {{tab_name}} {.unnumbered}",
        "```{r ribo-{{tab_name}}, message = FALSE, warning = FALSE}",
        "feature_plot_formatted(array, '{{dr_type}}', 'Ribo_proportion', c('lightgrey', 'blue'), NA)",  
        "```",
        ""
    )
    knit_expand(text = src)
}, dr_params$name, dr_params$type)
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

# Cluster nuclei {.tabset}

Clusters nuclei using Seurat's implementation of the Leiden clustering algorithm (see methods for references), which improves upon the more traditional Louvain algorithm. Clustering is performed at a variety of resolutions so that the best can be chosen from among the different results, ensuring optimal cluster assignments prior to downstream segmentation. 

```{r 21-leiden_clustering, message = FALSE, warning = FALSE}
array <- FindNeighbors(array, dims = 1:50, k.param = 30, verbose = FALSE)

res_index <- c(0.01, seq(0.1, 2, 0.1))
for (i in 1:length(res_index)){
  array <- FindClusters(array, method = 4, resolution = res_index[i], verbose = FALSE)
}
```

## Clustree {.tabset}

### Standard

```{r 22-clustree_standard, message = FALSE, warning = FALSE, fig.height = 8, fig.width = 14}
clustree(array, prefix = "SCT_snn_res.")
```

### Stability

```{r 23-clustree_stability, message = FALSE, warning = FALSE, fig.height = 8, fig.width = 14}
clustree(array, prefix = "SCT_snn_res.", node_colour = "sc3_stability")
```

## Scatter {.tabset}

### PCA {.tabset}

```{r 24-pca_res, message = FALSE, warning = FALSE, results = "hide"}
src_list <- lapply(res_index, function(res) {
    src <- c(
        "#### Res {{res}} {.unnumbered}",
        "```{r pca-res-{{res}}, message = FALSE, warning = FALSE}",
        "resolution_plot_formatted(array, 'pca', {{res}}, 'SCT')",  
        "```",
        ""
    )
    knit_expand(text = src)
})
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

### tSNE {.tabset}

```{r 25-tsne_res, message = FALSE, warning = FALSE, results = "hide"}
src_list <- lapply(res_index, function(res) {
    src <- c(
        "#### Res {{res}} {.unnumbered}",
        "```{r tsne-res-{{res}}, message = FALSE, warning = FALSE}",
        "resolution_plot_formatted(array, 'tsne', {{res}}, 'SCT')",  
        "```",
        ""
    )
    knit_expand(text = src)
})
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

### UMAP {.tabset}

```{r 26-umap_res, message = FALSE, warning = FALSE, results = "hide"}
src_list <- lapply(res_index, function(res) {
    src <- c(
        "#### Res {{res}} {.unnumbered}",
        "```{r umap-res-{{res}}, message = FALSE, warning = FALSE}",
        "resolution_plot_formatted(array, 'umap', {{res}}, 'SCT')",  
        "```",
        ""
    )
    knit_expand(text = src)
})
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

## Map {.tabset}

```{r 27-map_res, message = FALSE, warning = FALSE, results = "hide"}
src_list <- lapply(res_index, function(res) {
    src <- c(
        "### Res {{res}} {.unnumbered}",
        "```{r map-res-{{res}}, message = FALSE, warning = FALSE}",
        "SpatialDimPlot(array, label = TRUE, pt.size.factor = 5, 
                        group.by = 'SCT_snn_res.{{res}}', label.size = 3)",  
        "```",
        ""
    )
    knit_expand(text = src)
})
out <- knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

# Cut down to plCoA {.tabset}

## Cropped region

```{r 28-map_plCoA, message = FALSE, warning = FALSE, results = "hide"}
front_bound <- 196
back_bound <- 233
top_bound <- 0
bottom_bound <- 140

SpatialDimPlot(array, pt.size.factor = 4,
               cells.highlight = WhichCells(array, 
                                            expression = slice1_imagecol > front_bound & 
                                                         slice1_imagecol < back_bound & 
                                                         slice1_imagerow > top_bound &
                                                         slice1_imagerow < bottom_bound))
```

## Zoomed clusters

```{r 29-zoom_plCoA, message = FALSE, warning = FALSE, results = "hide"}
cropped_array <- subset(array, slice1_imagecol > front_bound & 
                               slice1_imagecol < back_bound & 
                               slice1_imagerow > top_bound &
                               slice1_imagerow < bottom_bound)

SpatialDimPlot(cropped_array, pt.size.factor = 25, crop = TRUE)
```

## plCoA features {.tabset}

### Genes

```{r 30-complexity_map_genes_cropped, warning = FALSE, message = FALSE}
SpatialFeaturePlot(cropped_array, features = "nFeature_Spatial", pt.size.factor = 25) + 
  theme(legend.position = "right")
```

### UMIs

```{r 31-complexity_map_umis_cropped, warning = FALSE, message = FALSE}
SpatialFeaturePlot(cropped_array, features = "nCount_Spatial", pt.size.factor = 25) + 
  theme(legend.position = "right")
```

### Mito proportion

```{r 32-mito_map_cropped, warning = FALSE, message = FALSE}
SpatialFeaturePlot(cropped_array, features = "Mito_proportion", pt.size.factor = 25) + 
  theme(legend.position = "right")
```

### Ribo proportion

```{r 33-ribo_map_cropped, warning = FALSE, message = FALSE}
SpatialFeaturePlot(cropped_array, features = "Ribo_proportion", pt.size.factor = 25) + 
  theme(legend.position = "right")
```

# Save arrays

```{r 34-save_arrays, warning = FALSE, message = FALSE}
saveRDS(array, file = paste0(output_path, "full_array.rds"))
saveRDS(cropped_array, file = paste0(output_path, "cropped_array.rds"))
```
